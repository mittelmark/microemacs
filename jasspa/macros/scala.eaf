 "" "</FOLD><FOLD+> \CCCControl Flow:\CCA"
fe "for (\p <- ...) {\r\r}\r\P" "  \CCDf\CCAror\CCDe\CCAach"
map "val \p = Map(\"key1\" -> val1, \"key2\" -> val2)\P" "  \CCDmap\CCA"
tcf "try {\r\p\r} catch {\r\r} finally {\r\r}\r\P" "  \CCDt\CCAry \CCDcf\CCA"
tc "try {\r\p\r} catch {\r\r}\r\P" "  \CCDt\CCAry \CCDc\CCAatch"
cl "class \p () {\r\r}\r\P" "  \CCDcl\CCAass"
pr "println(\p);\P" "  \CCDpr\CCAintln"
if "if (\p) {\r\r}\P" "  \CCDif\CCA"
ei "else if (\p) {\r\r}\P" "  \CCDe\\CCAlse \CCDi\CCAf"
el "else {\r\p\r}\P" "  \CCDel\CCAse"
fo "for (i <- 0 to \p) {\r\r}\P" "  \CCDfo\CCAr"
wh "while (\p) {\r\r}\P" "  \CCDwh\CCAile"
do "do {\r\r} while (\p)\r\P" "  \CCDdo\CCA while"
de "def \p (): void = {\r\r}\P" "  \CCDde\CCAf"
tr "trait \p {\r\r}\r\P" "  \CCDtr\CCAait"
ml "\"\"\"\r\r\"\"\".stripMargin\r\P" "  \CCDml\CCAstring"
imrl "import scala.io.StdIn.readLine\r\p=readline()\r\P" "  \CCDim\CCAport \\CCDr\CCAead\CCDl\CCAine"
imab "import scala.collection.mutable.ArrayBuffer\rval \pArrayBuffer[type]()\r\P" "  \CCDim\CCAport \\CCDa\CCarray\CCDb\CCAuffer"
imma "import scala.collection.mutable.Map\rval \p = collection.mutable.Map(\"key\" =>value)\r\P" "  \CCDim\CCAport \\CCDa\CCma\CCDp"
fkv "for ((key,val) <- \pmapvar) {\r\r}\r\P" "  \CCDf\CCAor \CCDkv\CCA"
fy "val res = for (n <- \p) yield ...\r" "  \CCDf\CCAor \CCDyCCAield"
ma "val res = \p match {\r case 1 => \"one\"\rcase 2 => \"two\"\r_ => \"invalid\r"\r}" "  \CCDma\CCAtch"
cn "def this(\p) {\r\r}\r\P" "  \CCDco\CCAnstructor"
me "def \p () : void = {\r\r}\r\P" "  \CCDme\CCAthod"
en "sealed trait \p\rcase object ValOne extends ...\r\P" "  \CCDen\CCAum"

in "interface \p {\rfunc:() => number;\r}\r\P" "  \CCDin\CCAterface"
 "" ""
