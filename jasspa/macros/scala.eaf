 "" "</FOLD><FOLD+> \CCDControl Flow:\CCA"
cl "class \p () {\r\r}\r\P" "  \CCDcl\CCAass"
cn "def this(\p) {\r\r}\r\P" "  \CCDco\CCAnstructor"
de "def \p (): Unit = {\r\r}\P" "  \CCDde\CCAf"
do "do {\r\r} while (\p)\r\P" "  \CCDdo\CCA while"
ei "else if (\p) {\r\r}\P" "  \CCDe\CCAlse \CCDi\CCAf"
el "else {\r\p\r}\P" "  \CCDel\CCAse"
en "sealed trait \p\rcase object ValOne extends ...\r\P" "  \CCDen\CCAum"
fe "for (\p <- ...) {\r\r}\r\P" "  \CCDf\CCAor\CCDe\CCAach"
fkv "for ((key,val) <- \pmapvar) {\r\r}\r\P" "  \CCDf\CCAor \CCDkv\CCA"
fo "for (i <- 0 to \p) {\r\r}\P" "  \CCDfo\CCAr"
fy "val res = for (n <- \p) yield ...\r" "  \CCDf\CCAor \CCDy\CCAield"
if "if (\p) {\r\r}\P" "  \CCDif\CCA"
imab "import scala.collection.mutable.ArrayBuffer\rval \pArrayBuffer[type]()\r\P" "  \CCDim\CCAport \CCDa\CCArray\CCDb\CCAuffer"
imma "import scala.collection.mutable.Map\rval \p = collection.mutable.Map(\"key\" =>value)\r\P" "  \CCDim\CCAport \CCDma\CCAp"
imrl "import scala.io.StdIn.readLine\r\p=readline()\r\P" "  \CCDim\CCAport \CCDr\CCAead\CCDl\CCAine"
ma "val res = \p match {\r case 1 => \"one\"\rcase 2 => \"two\"\r_ => \"invalid\r"\r}" "  \CCDma\CCAtch"
map "val \p = Map(\"key1\" -> val1, \"key2\" -> val2)\P" "  \CCDmap\CCA"
me "def \p () : void = {\r\r}\r\P" "  \CCDme\CCAthod"
ml "\"\"\"\r\r\"\"\".stripMargin\r\P" "  \CCDml\CCAstring"
pr "println(\p);\P" "  \CCDpr\CCAintln"
tc "try {\r\p\r} catch {\r\r}\r\P" "  \CCDt\CCAry \CCDc\CCAatch"
tcf "try {\r\p\r} catch {\r\r} finally {\r\r}\r\P" "  \CCDt\CCAry \CCDcf\CCA"
tr "trait \p {\r\r}\r\P" "  \CCDtr\CCAait"
wh "while (\p) {\r\r}\P" "  \CCDwh\CCAile"
 "" ""
